# THIS FILE HAS BEEN AUTO-GENERATED BY "PRISMA DEPLOY"
# DO NOT EDIT THIS FILE DIRECTLY

#
# Model Types
#

type Attendees implements Node {
  id: ID!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

type Post implements Node {
  id: ID!
  isPublished: Boolean!
  title: String!
  text: String!
}

type Retrospective implements Node {
  id: ID!
  title: String!
  sprint(where: SprintWhereInput): Sprint!
  isEnabled: Boolean!
}

type Sprint implements Node {
  id: ID!
  title: String!
  startsAt: DateTime!
  endsAt: DateTime!
  isEnabled: Boolean!
}


#
# Other Types
#

type AggregateAttendees {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateRetrospective {
  count: Int!
}

type AggregateSprint {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AttendeesConnection {
  pageInfo: PageInfo!
  edges: [AttendeesEdge]!
  aggregate: AggregateAttendees!
}

input AttendeesCreateInput {
  users: UserCreateManyInput
}

type AttendeesEdge {
  node: Attendees!
  cursor: String!
}

enum AttendeesOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AttendeesPreviousValues {
  id: ID!
}

type AttendeesSubscriptionPayload {
  mutation: MutationType!
  node: Attendees
  updatedFields: [String!]
  previousValues: AttendeesPreviousValues
}

input AttendeesSubscriptionWhereInput {
  AND: [AttendeesSubscriptionWhereInput!]
  OR: [AttendeesSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AttendeesWhereInput
}

input AttendeesUpdateInput {
  users: UserUpdateManyInput
}

input AttendeesWhereInput {
  AND: [AttendeesWhereInput!]
  OR: [AttendeesWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  users_every: UserWhereInput
  users_some: UserWhereInput
  users_none: UserWhereInput
}

input AttendeesWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  createSprint(data: SprintCreateInput!): Sprint!
  createRetrospective(data: RetrospectiveCreateInput!): Retrospective!
  createAttendees(data: AttendeesCreateInput!): Attendees!
  createUser(data: UserCreateInput!): User!
  createPost(data: PostCreateInput!): Post!
  updateSprint(data: SprintUpdateInput!, where: SprintWhereUniqueInput!): Sprint
  updateRetrospective(data: RetrospectiveUpdateInput!, where: RetrospectiveWhereUniqueInput!): Retrospective
  updateAttendees(data: AttendeesUpdateInput!, where: AttendeesWhereUniqueInput!): Attendees
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  deleteSprint(where: SprintWhereUniqueInput!): Sprint
  deleteRetrospective(where: RetrospectiveWhereUniqueInput!): Retrospective
  deleteAttendees(where: AttendeesWhereUniqueInput!): Attendees
  deletePost(where: PostWhereUniqueInput!): Post
  upsertSprint(where: SprintWhereUniqueInput!, create: SprintCreateInput!, update: SprintUpdateInput!): Sprint!
  upsertRetrospective(where: RetrospectiveWhereUniqueInput!, create: RetrospectiveCreateInput!, update: RetrospectiveUpdateInput!): Retrospective!
  upsertAttendees(where: AttendeesWhereUniqueInput!, create: AttendeesCreateInput!, update: AttendeesUpdateInput!): Attendees!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  updateManySprints(data: SprintUpdateInput!, where: SprintWhereInput!): BatchPayload!
  updateManyRetrospectives(data: RetrospectiveUpdateInput!, where: RetrospectiveWhereInput!): BatchPayload!
  updateManyAttendeeses(data: AttendeesUpdateInput!, where: AttendeesWhereInput!): BatchPayload!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): BatchPayload!
  updateManyPosts(data: PostUpdateInput!, where: PostWhereInput!): BatchPayload!
  deleteManySprints(where: SprintWhereInput!): BatchPayload!
  deleteManyRetrospectives(where: RetrospectiveWhereInput!): BatchPayload!
  deleteManyAttendeeses(where: AttendeesWhereInput!): BatchPayload!
  deleteManyUsers(where: UserWhereInput!): BatchPayload!
  deleteManyPosts(where: PostWhereInput!): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  isPublished: Boolean!
  title: String!
  text: String!
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  isPublished_ASC
  isPublished_DESC
  title_ASC
  title_DESC
  text_ASC
  text_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PostPreviousValues {
  id: ID!
  isPublished: Boolean!
  title: String!
  text: String!
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
}

input PostUpdateInput {
  isPublished: Boolean
  title: String
  text: String
}

input PostWhereInput {
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  isPublished: Boolean
  isPublished_not: Boolean
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
}

input PostWhereUniqueInput {
  id: ID
}

type Query {
  sprints(where: SprintWhereInput, orderBy: SprintOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sprint]!
  retrospectives(where: RetrospectiveWhereInput, orderBy: RetrospectiveOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Retrospective]!
  attendeeses(where: AttendeesWhereInput, orderBy: AttendeesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attendees]!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  sprint(where: SprintWhereUniqueInput!): Sprint
  retrospective(where: RetrospectiveWhereUniqueInput!): Retrospective
  attendees(where: AttendeesWhereUniqueInput!): Attendees
  post(where: PostWhereUniqueInput!): Post
  sprintsConnection(where: SprintWhereInput, orderBy: SprintOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SprintConnection!
  retrospectivesConnection(where: RetrospectiveWhereInput, orderBy: RetrospectiveOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RetrospectiveConnection!
  attendeesesConnection(where: AttendeesWhereInput, orderBy: AttendeesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AttendeesConnection!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  node(id: ID!): Node
}

type RetrospectiveConnection {
  pageInfo: PageInfo!
  edges: [RetrospectiveEdge]!
  aggregate: AggregateRetrospective!
}

input RetrospectiveCreateInput {
  title: String!
  isEnabled: Boolean
  sprint: SprintCreateOneInput!
}

type RetrospectiveEdge {
  node: Retrospective!
  cursor: String!
}

enum RetrospectiveOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  isEnabled_ASC
  isEnabled_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type RetrospectivePreviousValues {
  id: ID!
  title: String!
  isEnabled: Boolean!
}

type RetrospectiveSubscriptionPayload {
  mutation: MutationType!
  node: Retrospective
  updatedFields: [String!]
  previousValues: RetrospectivePreviousValues
}

input RetrospectiveSubscriptionWhereInput {
  AND: [RetrospectiveSubscriptionWhereInput!]
  OR: [RetrospectiveSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RetrospectiveWhereInput
}

input RetrospectiveUpdateInput {
  title: String
  isEnabled: Boolean
  sprint: SprintUpdateOneInput
}

input RetrospectiveWhereInput {
  AND: [RetrospectiveWhereInput!]
  OR: [RetrospectiveWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  isEnabled: Boolean
  isEnabled_not: Boolean
  sprint: SprintWhereInput
}

input RetrospectiveWhereUniqueInput {
  id: ID
}

type SprintConnection {
  pageInfo: PageInfo!
  edges: [SprintEdge]!
  aggregate: AggregateSprint!
}

input SprintCreateInput {
  title: String!
  startsAt: DateTime!
  endsAt: DateTime!
  isEnabled: Boolean
}

input SprintCreateOneInput {
  create: SprintCreateInput
  connect: SprintWhereUniqueInput
}

type SprintEdge {
  node: Sprint!
  cursor: String!
}

enum SprintOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  startsAt_ASC
  startsAt_DESC
  endsAt_ASC
  endsAt_DESC
  isEnabled_ASC
  isEnabled_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type SprintPreviousValues {
  id: ID!
  title: String!
  startsAt: DateTime!
  endsAt: DateTime!
  isEnabled: Boolean!
}

type SprintSubscriptionPayload {
  mutation: MutationType!
  node: Sprint
  updatedFields: [String!]
  previousValues: SprintPreviousValues
}

input SprintSubscriptionWhereInput {
  AND: [SprintSubscriptionWhereInput!]
  OR: [SprintSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SprintWhereInput
}

input SprintUpdateInput {
  title: String
  startsAt: DateTime
  endsAt: DateTime
  isEnabled: Boolean
}

input SprintUpdateOneInput {
  create: SprintCreateInput
  connect: SprintWhereUniqueInput
  disconnect: SprintWhereUniqueInput
  delete: SprintWhereUniqueInput
}

input SprintWhereInput {
  AND: [SprintWhereInput!]
  OR: [SprintWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  startsAt: DateTime
  startsAt_not: DateTime
  startsAt_in: [DateTime!]
  startsAt_not_in: [DateTime!]
  startsAt_lt: DateTime
  startsAt_lte: DateTime
  startsAt_gt: DateTime
  startsAt_gte: DateTime
  endsAt: DateTime
  endsAt_not: DateTime
  endsAt_in: [DateTime!]
  endsAt_not_in: [DateTime!]
  endsAt_lt: DateTime
  endsAt_lte: DateTime
  endsAt_gt: DateTime
  endsAt_gte: DateTime
  isEnabled: Boolean
  isEnabled_not: Boolean
}

input SprintWhereUniqueInput {
  id: ID
}

type Subscription {
  sprint(where: SprintSubscriptionWhereInput): SprintSubscriptionPayload
  retrospective(where: RetrospectiveSubscriptionWhereInput): RetrospectiveSubscriptionPayload
  attendees(where: AttendeesSubscriptionWhereInput): AttendeesSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
}

type User {
  avatar: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  avatar: String
}

input UserCreateManyInput {
  create: [UserCreateInput!]
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  avatar_ASC
  avatar_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  avatar: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateInput {
  avatar: String
}

input UserUpdateManyInput {
  create: [UserCreateInput!]
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
}
